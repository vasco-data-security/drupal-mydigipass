<?php
/**
 * @file
 * mydigipass provides authentication against the MYDIGIPASS.COM service of
 * VASCO Data Security.
 *
 * For more information about MYDIGIPASS.COM go to https://mydigipass.com
 * To create a free account in the sandbox environment, go to
 * https://developer.mydigipass.com
 */

/**
 * Implements hook_menu().
 */
function mydigipass_menu() {
  $items = array();

  $items['admin/settings/mydigipass'] = array(
    'title' => 'MYDIGIPASS.COM',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mydigipass_admin_settings'),
    'description' => 'Configure MYDIGIPASS.COM settings',
    'access arguments' => array('administer mydigipass'),
    'file' => 'mydigipass.admin.inc.php',
  );

  $items['admin/settings/mydigipass/account_settings'] = array(
    'title' => 'Account settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 10,
  );

  $items['admin/settings/mydigipass/user_data_fields'] = array(
    'title' => 'User data fields',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mydigipass_admin_settings_user_profile_fields_form'),
    'description' => "Configure the MYDIGIPASS.COM user data fields which are shown in the user's profile",
    'access arguments' => array('administer mydigipass'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'mydigipass.admin.inc.php',
    'weight' => 30,
  );

  $items['admin/settings/mydigipass/button_style'] = array(
    'title' => 'Button style',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mydigipass_admin_settings_button_style_form'),
    'description' => 'Configure the MYDIGIPASS.COM buttons which are shown in different forms',
    'access arguments' => array('administer mydigipass'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'mydigipass.admin.inc.php',
    'weight' => 20,
  );

  $items['admin/settings/mydigipass/advanced_settings'] = array(
    'title' => 'Advanced settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mydigipass_admin_settings_advanced_form'),
    'description' => 'Configure MYDIGIPASS.COM advanced settings, such as SSL server certificate validation and MYDIGIPASS.COM endpoint API URLs.',
    'access arguments' => array('administer mydigipass'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'mydigipass.admin.inc.php',
    'weight' => 40,
  );

  $items['mydigipass/callback'] = array(
    'title' => 'MYDIGIPASS.COM callback',
    'page callback' => 'mydigipass_callback',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'callback.inc.php',
  );

  $items['mydigipass/link'] = array(
    'title' => 'Link MYDIGIPASS.COM account',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mydigipass_link_user_form'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['mydigipass/link/new_user'] = array(
    'title' => 'Link to new account',
    'page callback' => 'mydigipass_link_new_user',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['mydigipass/link/existing_user'] = array(
    'title' => 'Link to existing user',
    'page callback' => 'mydigipass_link_existing_user',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_perm().
 */
function mydigipass_perm() {
  return array('administer mydigipass');
}

/**
 * Implements hook_init().
 *
 * It is necessary to add the javascript using hook_init() and not with
 * drupal_add_js() since the javascript is a javascript file which has to be
 * loaded from a third party website.
 */
function mydigipass_init() {
  // Only include if the integration has been enabled.
  if (variable_get('mydigipass_integration_enabled', 0) == 1) {
    $endpoint = _mydigipass_get_endpoint_url('dp_connect.js');
    if (!empty($endpoint)) {
      drupal_set_html_head('<script type="text/javascript" src="' . $endpoint . '"></script>');
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function mydigipass_form_alter(&$form, $form_state, $form_id) {
  // If the integration is not enabled, don't alter any forms.
  if (variable_get('mydigipass_integration_enabled', 0) == 0) {
    return;
  }

  switch ($form_id) {
    // The standard login form.
    case 'user_login_block':
    case 'user_login':
      // Generate a random 32-char string. This string serves as a csrf token
      // to detect that the click originated from within this session. It will
      // be used as a value for the state parameter and is stored in this user's
      // session. This allows to verify that the end-user effectively clicked
      // the button to link and will avoid that a CSRF-alike attack is being
      // performed on a logged-on end-user by a malicious person.
      if (empty($_SESSION['mydigipass_login_csrf_token'])) {
        $_SESSION['mydigipass_login_csrf_token'] = user_password(32);
      }

      // Prepare the value for the state parameter.
      $state_array = array(
        'csrf_token' => $_SESSION['mydigipass_login_csrf_token'],
        'action' => 'login',
      );
      $state_string = _mydigipass_encode_state_array($state_array);

      // Add the MYDIGIPASS.COM button.
      $form['account']['mydigipass'] = array(
        '#type' => 'item',
        '#value' => l(t('Connect with MYDIGIPASS.COM'), '', array(
          'fragment' => ' ',
          'external' => TRUE,
          'attributes' => array(
            'class' => 'dpplus-connect',
            'data-client-id' => check_plain(variable_get('mydigipass_client_id', '')),
            'data-redirect-uri' => check_plain(variable_get('mydigipass_callback_url', url('mydigipass/callback', array('absolute' => TRUE)))),
            'data-state' => $state_string,
            'data-style' => variable_get('mydigipass_login_form_style', 'default'),
            'data-text' => variable_get('mydigipass_login_form_text', 'secure-login'),
            'data-help' => variable_get('mydigipass_login_form_help', 'true'),
          ),
        )),
      );
      // Add mydigipass_enforce_authentication_mode_during_login as first
      // validation handler.
      array_unshift($form['#validate'], 'mydigipass_enforce_authentication_mode_during_login');
      break;

    // The form which allows to reset your password.
    case 'user_pass':
      // Add mydigipass_enforce_authentication_mode_during_password_reset as
      // first validation handler.
      array_unshift($form['#validate'], 'mydigipass_enforce_authentication_mode_during_password_reset');
      break;

    // The standard user registration form.
    case 'user_register':
      // Generate a random 32-char string. This string serves as a csrf token
      // to detect that the click originated from within this session. It will
      // be used as a value for the state parameter and is stored in this user's
      // session. This allows to verify that the end-user effectively clicked
      // the button to link and will avoid that a CSRF-alike attack is being
      // performed on a logged-on end-user by a malicious person.
      if (empty($_SESSION['mydigipass_register_csrf_token'])) {
        $_SESSION['mydigipass_register_csrf_token'] = user_password(32);
      }

      // Prepare the value for the state parameter.
      $state_array = array(
        'csrf_token' => $_SESSION['mydigipass_register_csrf_token'],
        'action' => 'register',
      );
      $state_string = _mydigipass_encode_state_array($state_array);

      $form['mydigipass'] = array(
        '#type' => 'item',
        '#value' => l(t('Connect with MYDIGIPASS.COM'), '', array(
          'fragment' => ' ',
          'external' => TRUE,
          'attributes' => array(
            'class' => 'dpplus-connect',
            'data-client-id' => check_plain(variable_get('mydigipass_client_id', '')),
            'data-redirect-uri' => check_plain(variable_get('mydigipass_callback_url', url('mydigipass/callback', array('absolute' => TRUE)))),
            'data-state' => $state_string,
            'data-style' => variable_get('mydigipass_register_form_style', 'large'),
            'data-text' => variable_get('mydigipass_register_form_text', 'sign-up'),
            'data-help' => variable_get('mydigipass_login_form_help', 'true'),
          ),
        )),
      );
      break;

    // The form shown on the mydigipass link page when the end-user indicated
    // that he/she already had a Drupal account.
    case 'mydigipass_user_login':
      // Change the text on the submit button.
      $form['submit']['#value'] = t('Link account to MYDIGIPASS.COM');

      // Add a submit handler which links the MYDIGIPASS.COM account to the
      // logged on user. If authentication fails, the submit handler will not be
      // called since the request will be stopped by the validation handler(s).
      $form['#submit'][] = 'mydigipass_link_user_to_logged_on_user';
      // Add a validation handler which verifies whether the entered user is
      // already linked to a MYDIGIPASS.COM account.
      array_unshift($form['#validate'], 'mydigipass_verify_if_user_already_linked');
      break;

    // The form shown on the mydigipass link page when the end-user indicated
    // that he wants to create a new Drupal account.
    case 'mydigipass_user_register':
      // Fill in the email address received from MYDIGIPASS.COM
      $uuid = $_SESSION['mydigipass_uuid'];
      $sql = "SELECT attribute_value FROM {mydigipass_user_data} "
        . "WHERE mdp_uuid = '%s' AND attribute_key = 'email'";
      $mdp_email = db_result(db_query($sql, $uuid));
      $form['mail']['#default_value'] = $mdp_email;
      $form['name']['#default_value'] = $mdp_email;
      // The value of the password doesn't really matter since a random
      // password is created and stored when the user is effectively created.
      $form['pass']['#type'] = 'value';
      $form['pass']['#value'] = user_password(32);

      // Change the text on the submit button.
      $form['submit']['#value'] = t('Create new account and link to MYDIGIPASS.COM');

      // Add a submit handler which creates a new user and links the
      // MYDIGIPASS.COM account this new user.
      // If authentication fails, the submit handler will not be called since
      // the request will be stopped by the validation handler(s).
      $form['#submit'][] = 'mydigipass_link_user_to_new_user';
      break;
  }
}

/**
 * Implements hook_forms().
 */
function mydigipass_forms() {
  // mydigipass_user_login is a slightly modified user_login form.
  $forms['mydigipass_user_login']['callback'] = 'user_login';
  // mydigipass_user_register is a slightly modified user_register form.
  $forms['mydigipass_user_register']['callback'] = 'user_register';

  return $forms;
}

/**
 * Implements hook_cron().
 */
function mydigipass_cron() {
  if (variable_get('mydigipass_connect_api_inconsistency', TRUE)) {
    // Important to negate the result of sync_connected_users:
    // api_inconsistency = TRUE if sync_connected_users = FALSE!
    variable_set('mydigipass_connect_api_inconsistency', !_mydigipass_sync_connected_users());
  }
}

/**
 * Implements hook_user().
 */
function mydigipass_user($op, &$edit, &$account, $category = NULL) {
  // Don't do anything if the integration is not enabled, unless $op is set to
  // 'delete'. When set to delete, personal data must also be deleted even if
  // the integration is (temporarily) disabled.
  if ((variable_get('mydigipass_integration_enabled', 0) == 0) &&
    ($op != 'delete')) {
    return;
  }

  switch ($op) {
    case 'view':
      // Check if the user is linked to a MYDIGIPASS.COM account.
      $sql = 'SELECT 1 FROM {mydigipass_user_link} WHERE drupal_uid = %d';
      $result = db_result(db_query($sql, $account->uid));
      if ($result == 1) {
        // The user is linked to a MYDIGIPASS.COM account, so extract the email
        // address of the MYDIGIPASS.COM account.
        $sql = "SELECT UD.attribute_value FROM {mydigipass_user_link} UL, {mydigipass_user_data} UD WHERE UL.drupal_uid = %d AND UL.mdp_uuid = UD.mdp_uuid AND UD.attribute_key = 'email'";
        $mdp_email = db_result(db_query($sql, $account->uid));
        $account->content['summary']['mydigipass'] = array(
          '#type' => 'user_profile_item',
          '#title' => 'MYDIGIPASS.COM',
          '#value' => t('This user account is linked to the following MYDIGIPASS.COM account: @mdp_email', array('@mdp_email' => $mdp_email)),
        );

        // Add the known MYDIGIPASS.COM user data of which the administrator
        // allowed it to be shown.
        $sql = "SELECT * FROM {mydigipass_user_link} UL LEFT JOIN {mydigipass_user_data} UD ON UL.mdp_uuid = UD.mdp_uuid LEFT JOIN {mydigipass_profile_fields} PF ON PF.name = UD.attribute_key WHERE UL.drupal_uid = %d AND PF.name IS NOT NULL AND PF.selected = 1 ORDER BY PF.weight ASC";
        $result = db_query($sql, $account->uid);

        if ($result && db_affected_rows() > 0) {
          $account->content['mydigipass_user_data'] = array(
            '#type' => 'user_profile_category',
            '#title' => t('MYDIGIPASS.COM user data'),
            '#description' => t('This data is information which was obtained from MYDIGIPASS.COM.'),
          );
          while ($row = db_fetch_object($result)) {
            $account->content['mydigipass_user_data'][$row->attribute_key] = array(
              '#type' => 'user_profile_item',
              '#title' => (empty($row->title) ? t($row->attribute_key) : t($row->title)),
              '#value' => check_plain($row->attribute_value),
              '#attributes' => array('class' => 'profile-' . check_plain($row->attribute_key)),
              '#weight' => $row->weight,
            );
          }
        }
      }
      else {
        $account->content['summary']['mydigipass'] = array(
          '#type' => 'user_profile_item',
          '#title' => 'MYDIGIPASS.COM',
          '#value' => t('This user account is not yet linked to a MYDIGIPASS.COM account.'),
        );
      }
      break;

    case 'form':
      return mydigipass_form_profile($edit, $account);

    case 'delete':
      // A user account is being deleted. The personal data and the link with
      // MYDIGIPASS.COM should also be deleted.
      // Lookup the MYDIGIPASS.COM uuid which is associated with the user.
      $sql = "SELECT mdp_uuid FROM {mydigipass_user_link} WHERE drupal_uid = %d";
      $uuid = db_result(db_query($sql, $account->uid));

      // Delete the link between the Drupal user and the MYDIGIPASS.COM user.
      $sql = "DELETE FROM {mydigipass_user_link} WHERE mdp_uuid = '%s'";
      db_query($sql, $uuid);

      // Delete the personal data of the MYDIGIPASS.COM user.
      $sql = "DELETE FROM {mydigipass_user_data} WHERE mdp_uuid = '%s'";
      db_query($sql, $uuid);

      // Inform MYDIGIPASS.COM of the removal of the link with MYDIGIPASS.COM.
      _mydigipass_api_uuid_disconnected($uuid);

      break;

    case 'login':
      // Check if this site is configured in "MYDIGIPASS.COM only" mode. If so,
      // it is important to check if the MYDIGIPASS.COM uuid has been set in the
      // current session. If so, then this indicates that the user has already
      // been authenticated by MYDIGIPASS.COM. If the uuid is not yet set in the
      // session, then the user tries to authenticate via some other means which
      // is not allowed. An occasion in which this may occur is if the user
      // received an email with a one-time login URL.
      if (variable_get('mydigipass_authentication_mode', 'mdp_only') == 'mdp_only') {
        $sql = "SELECT 1 FROM {mydigipass_user_link} UL WHERE UL.drupal_uid = %d";
        $result = db_result(db_query($sql, $account->uid));

        if (($result == 1) && empty($_SESSION['mydigipass_uuid'])) {
          global $user;
          // Load the anonymous user.
          $user = drupal_anonymous_user();
          drupal_set_message(t("This user account has been linked to a MYDIGIPASS.COM account. According to this website's policy, an account linked to MYDIGIPASS.COM can only logon via MYDIGIPASS.COM."), 'error');
          watchdog('mydigipass', 'The session for user %uid has been destroyed since the user managed to logon by not using MYDIGIPASS.COM.', array('%uid' => $account->uid), WATCHDOG_ERROR);
          // Redirect the user to the front-page. If this is not done, the user
          // can receive an access denied page in some cases (e.g. when using a
          // one-time login.
          drupal_goto('<front>');
        }
      }
      break;
  }
}

/**
 * Form validation handler to enforce the authentication mode during login.
 *
 * Form validation handler of the login form which enforces the authentication
 * mode. If the authentication mode is set to mdp_only and the account is
 * linked to MYDIGIPASS.COM then logon is denied.
 */
function mydigipass_enforce_authentication_mode_during_login($form, &$form_state) {
  if (variable_get('mydigipass_authentication_mode', 'mdp_only') == 'mdp_only') {
    $sql = "SELECT 1 FROM {mydigipass_user_link} UL, {users} U WHERE U.uid = UL.drupal_uid AND U.name = '%s'";
    $result = db_result(db_query($sql, trim($form_state['values']['name'])));

    if ($result == 1) {
      form_set_error('name', t("This user account has been linked to a MYDIGIPASS.COM account. According to this website's policy, an account linked to MYDIGIPASS.COM can only logon via MYDIGIPASS.COM."));
    }
  }
}

/**
 * Form validation handler for user_pass().
 *
 * Form validation handler of the password reset form which enforces the
 * authentication mode. If the authentication mode is set to mdp_only and the
 * account is linked to MYDIGIPASS.COM then resetting the user's password is
 * denied.
 */
function mydigipass_enforce_authentication_mode_during_password_reset($form, &$form_state) {
  if (variable_get('mydigipass_authentication_mode', 'mdp_only') == 'mdp_only') {
    $sql = "SELECT 1 FROM {mydigipass_user_link} UL, {users} U WHERE U.uid = UL.drupal_uid AND (U.name = '%s' OR U.mail = '%s')";
    $result = db_result(db_query($sql, trim($form_state['values']['name']), trim($form_state['values']['name'])));

    if ($result == 1) {
      form_set_error('name', t("This user account has been linked to a MYDIGIPASS.COM account. According to this website's policy, an account linked to MYDIGIPASS.COM can only logon via MYDIGIPASS.COM. As such you cannot use the password reset functionality."));
    }
  }
}

/**
 * Form validation handler which checks if a user is already linked to MDP.
 *
 * Form validation handler which is called after the mydigipass_user_login
 * form. This handler will stop the link process if it detects that the
 * end-user is trying to link his MYDIGIPASS.COM account to a Drupal user who
 * is already linked to another MYDIGIPASS.COM account.
 */
function mydigipass_verify_if_user_already_linked($form, &$form_state) {
  $sql = "SELECT 1 FROM {mydigipass_user_link} UL, {users} U WHERE U.uid = UL.drupal_uid AND U.name = '%s'";
  $result = db_result(db_query($sql, trim($form_state['values']['name'])));

  if ($result == 1) {
    form_set_error('name', t("The username %name has already been linked to a MYDIGIPASS.COM account. A user can only be linked to one MYDIGIPASS.COM account.", array('%name' => $form_state['values']['name'])));
  }
}

/**
 * Form submit handler which links an existing user to a MYDIGIPASS.COM user.
 *
 * Form submit handler which is called after the mydigipass_user_login
 * form. The validation handlers of the form will ensure that the user object
 * is loaded. This submit handler performs the actual linking.
 */
function mydigipass_link_user_to_logged_on_user($form, &$form_state) {
  global $user;
  $uuid = $_SESSION['mydigipass_uuid'];
  // Link the Drupal user to the MYDIGIPASS.COM user.
  $sql = "INSERT INTO {mydigipass_user_link} (drupal_uid, mdp_uuid) VALUES (%d, '%s')";
  $success = db_query($sql, $user->uid, $uuid);

  if ($success) {
    drupal_set_message(t('The user has been successfully linked to MYDIGIPASS.COM.'));
    // Inform MYDIGIPASS.COM of the link of the user.
    _mydigipass_api_uuid_connected($uuid);
  }
  else {
    drupal_set_message(t('An error occurred while linking the user to MYDIGIPASS.COM.'), 'error');
  }
}

/**
 * Creates a new user and links it to a MYDIGIPASS.COM user.
 *
 * Form submit handler which is called after the mydigipass_user_register
 * form. This submit handler creates a new user and links this user to the
 * MYDIGIPASS.COM user. The new user is created with a random password.
 */
function mydigipass_link_user_to_new_user($form, &$form_state) {
  global $user;

  $new_username = $form_state['values']['name'];

  // Register the new user.
  user_external_login_register($new_username, 'mydigipass');

  // user_external_login_register() creates a new account, but only sets the
  // name of the user. The email address should also be set.
  $uuid = $_SESSION['mydigipass_uuid'];
  $sql = "SELECT attribute_value FROM {mydigipass_user_data} WHERE mdp_uuid = '%s' AND attribute_key = 'email'";
  $mail = db_result(db_query($sql, $uuid));
  $sql = "UPDATE {users} SET mail = '%s', init = '%s' WHERE uid = %d";
  db_query($sql, $form_state['values']['mail'], $mail, $user->uid);
  // Also store the email in the $user object.
  $user->mail = $form_state['values']['mail'];

  // Link the new user to MYDIGIPASS.COM
  mydigipass_link_user_to_logged_on_user($form, $form_state);

  // Check whether administrator approval is needed.
  if (variable_get('user_register', 1) == 1) {
    $registered_user = $user;
    // Reset the $user object. user_external_login() behaves strangely
    // if this isn't done, even if $user->uid is set to 0.
    $user = drupal_anonymous_user();
    // The following statement will restore $user.
    user_external_login($registered_user);

    drupal_set_message(t('Registration successful. You are now logged in.'));

    drupal_goto('<front>');
  }
  else {
    // user_external_login_register() automatically sets the account status
    // to 'enabled'. However, the administrator wants to approve accounts
    // first. So disable the account.
    $sql = "UPDATE {users} SET status = 0 WHERE uid = %d";
    db_query($sql, $user->uid);

    // Administrator approval required.
    _user_mail_notify('register_pending_approval', $user);
    drupal_set_message(t('Thank you for applying for an account. Your account is currently pending approval by the site administrator.<br />In the meantime, a welcome message with further instructions has been sent to your e-mail address.'));
    $form_state['redirect'] = '';

    // Reset the $user object.
    $user = drupal_anonymous_user();
  }
}

/**
 * Generates the form items which are added when editing a user account.
 *
 * This function generates the different form items which are added to the form
 * which is displayed when a user is edited. It behaves as follows: when the
 * user is linked to MYDIGIPASS.COM, then it shows a button which allows
 * unlinking. When the user is not yet linked, a MYDIGIPASS.COM button is shown
 * which allows to link to MYDIGIPASS.COM.
 */
function mydigipass_form_profile($edit, $account) {
  $form = array();
  $form['mydigipass'] = array(
    '#type' => 'fieldset',
    '#title' => 'MYDIGIPASS.COM',
  );

  // Check if the user is linked to a MYDIGIPASS.COM account.
  $sql = 'SELECT 1 FROM {mydigipass_user_link} WHERE drupal_uid = %d';
  $result = db_result(db_query($sql, $account->uid));
  if ($result == 1) {
    // The user is linked with a MYDIGIPASS.COM account.
    $sql = "SELECT attribute_value FROM {mydigipass_user_link} UL, {mydigipass_user_data} UD WHERE UL.drupal_uid = %d AND UL.mdp_uuid = UD.mdp_uuid AND UD.attribute_key = 'email'";
    $mdp_email = db_result(db_query($sql, $account->uid));
    $form['mydigipass'][] = array(
      '#type' => 'item',
      '#value' => t('This user account is linked to the following MYDIGIPASS.COM account: @mdp_email', array('@mdp_email' => $mdp_email)),
    );
    $form['mydigipass'][] = array(
      '#type' => 'submit',
      '#title' => t('Unlink from MYDIGIPASS.COM'),
      '#value' => t('Unlink'),
      '#description' => t('Use the following button to unlink your account from MYDIGIPASS.COM'),
      '#submit' => array('mydigipass_form_profile_unlink'),
    );

  }
  else {
    // The user is not yet linked with a MYDIGIPASS.COM account.
    // Only show the 'Link with MYDIGIPASS.COM'-button if the logged on user is
    // the same as the one who is viewing this profile. This to avoid that an
    // administrator would link his MYDIGIPASS.COM account by accident to
    // another Drupal user's profile.
    global $user;
    if ($user->uid == $account->uid) {
      $form['mydigipass'][] = array(
        '#type' => 'item',
        '#value' => t('Click on the button below to secure your account with MYDIGIPASS.COM.'),
      );

      // Generate a random 32-char string. This string serves as a csrf token
      // to detect that the click originated from within this session. It will
      // be used as a value for the state parameter and is stored in this user's
      // session. This allows to verify that the end-user effectively clicked
      // the button to link and will avoid that a CSRF-alike attack is being
      // performed on a logged-on end-user by a malicious person.
      if (empty($_SESSION['mydigipass_link_csrf_token'])) {
        $_SESSION['mydigipass_link_csrf_token'] = user_password(32);
      }

      // Prepare the value for the state parameter.
      $state_array = array(
        'csrf_token' => $_SESSION['mydigipass_link_csrf_token'],
        'action' => 'link',
      );
      $state_string = _mydigipass_encode_state_array($state_array);

      // The MYDIGIPASS.COM button also contains the data-state parameter.
      $form['mydigipass'][] = array(
        '#type' => 'item',
        '#value' => l(t('Connect with MYDIGIPASS.COM'), '', array(
          'fragment' => ' ',
          'external' => TRUE,
          'attributes' => array(
            'class' => 'dpplus-connect',
            'data-client-id' => check_plain(variable_get('mydigipass_client_id', '')),
            'data-redirect-uri' => check_plain(variable_get('mydigipass_callback_url', url('mydigipass/callback', array('absolute' => TRUE)))),
            'data-state' => $state_string,
            'data-style' => variable_get('mydigipass_link_form_style', 'large'),
            'data-text' => variable_get('mydigipass_link_form_text', 'connect'),
            'data-help' => variable_get('mydigipass_login_form_help', 'true'),
          ),
        )),
      );
    }
    else {
      // Somebody else than the user himself is viewing the user's profile.
      $form['mydigipass'][] = array(
        '#type' => 'item',
        '#value' => t('This user account is not linked to a MYDIGIPASS.COM account.'),
      );
    }
  }

  return $form;
}

/**
 * Removes the link between the current user and MYDIGIPASS.COM.
 *
 * Submit handler called from mydigipass_form_profile();
 */
function mydigipass_form_profile_unlink($form, &$form_state) {
  // Lookup the MYDIGIPASS.COM uuid which is associated with the user.
  $sql = "SELECT mdp_uuid FROM {mydigipass_user_link} WHERE drupal_uid = %d";
  $uuid = db_result(db_query($sql, $form_state['values']['_account']->uid));

  // Delete the link between the Drupal user and the MYDIGIPASS.COM user.
  $sql = "DELETE FROM {mydigipass_user_link} WHERE mdp_uuid = '%s'";
  $success = db_query($sql, $uuid);

  if ($success) {
    // Caring about user privacy! Delete all attributes which were saved in
    // the database.
    $sql = "DELETE FROM {mydigipass_user_data} WHERE mdp_uuid = '%s'";
    db_query($sql, $uuid);
    drupal_set_message(t('Your account has been successfully unlinked. You can no longer log in with MYDIGIPASS.COM.'));
    // Inform MYDIGIPASS.COM of the unlink.
    _mydigipass_api_uuid_disconnected($uuid);
  }
  else {
    drupal_set_message(t('An error occurred while unlinking the account from MYDIGIPASS.COM'), 'error');
  }
}

/**
 * Private helper function which returns the URL of an endpoint.
 *
 * Return the URL of the token or data endpoint while taking into account the
 * environment which was selected on the admin page.
 *
 * @param string $endpoint
 *   The endpoint for which the URL is requested. Allowed values are
 *   'token_endpoint', 'data_endpoint', 'dp_connect.js', 'api-uuids-connected'
 *   and 'api-uuids-disconnected'.
 *
 * @return string
 *   The URL of the endpoint of an empty string is the environment is not yet
 *   selected or if the $endpoint value was wrong.
 */
function _mydigipass_get_endpoint_url($endpoint) {
  $environment = variable_get('mydigipass_environment', '');

  // Check if the environment is not set (i.e. the module is not yet
  // configured) or if it is set to a wrong value.
  if ($environment == '') {
    return '';
  }

  $base_url = ($environment == 'test' ? 'https://sandbox.mydigipass.com' : ($environment == 'production' ? 'https://mydigipass.com' : ''));

  $return = '';
  switch ($endpoint) {
    case 'token_endpoint':
      $return = ($environment == 'custom' ? variable_get('mydigipass_endpoint_url_token_endpoint', '') : $base_url . '/oauth/token');
      break;

    case 'data_endpoint':
      $return = ($environment == 'custom' ? variable_get('mydigipass_endpoint_url_data_endpoint', '') : $base_url . '/oauth/user_data');
      break;

    case 'dp_connect.js':
      if ($environment == 'test') {
        $return = 'https://mydigipass.com/sandbox/dp_connect.js';
      }
      elseif ($environment == 'custom') {
        $return = variable_get('mydigipass_endpoint_url_dp_connect_js', '');
      }
      else {
        $return = $base_url . '/dp_connect.js';
      }
      break;

    case 'api-uuids-connected':
      $return = ($environment == 'custom' ? variable_get('mydigipass_endpoint_url_api_uuids_connected', '') : $base_url . '/api/uuids/connected');
      break;

    case 'api-uuids-disconnected':
      $return = ($environment == 'custom' ? variable_get('mydigipass_endpoint_url_api_uuids_disconnected', '') : $base_url . '/api/uuids/disconnected');
      break;

  }
  return $return;
}

/**
 * Page callback for 'mydigipass/link'.
 *
 * Shows the first page of a wizard which allows a MYDIGIPASS.COM user to link
 * his/her MYDIGIPASS.COM account to a Drupal account.
 *
 * An end-user arrives on this page when after having authenticated at
 * MYDIGIPASS.COM and after having been redirected to the callback page. The
 * callback page detected that the MYDIGIPASS.COM was not yet linked to a
 * Drupal account and redirects the end-user to the "Link with MYDIGIPASS.COM"
 * wizard. The first page of this wizard allows the end-user to choose between
 * linking his MYDIGIPASS.COM account to an existing Drupal account or to
 * create a new Drupal account and link immediately to his/her MYDIGIPASS.COM
 * account.
 */
function mydigipass_link_user_form() {
  $form = array();

  // Check if the integration is enabled. When integration is not enabled, a
  // user could arrive at the callback page when forcefully browsing to
  // the 'mydigipass/link' page.
  if (variable_get('mydigipass_integration_enabled', 0) == 0) {
    $form[] = array(
      '#type' => 'item',
      '#value' => t('The integration with MYDIGIPASS.COM has been disabled on this website.'),
    );
  }
  else {
    $form[] = array(
      '#type' => 'item',
      '#value' => t("Your MYDIGIPASS.COM account is not yet linked to a user account on this website. If you already have a user account on this website, you can link it to your MYDIGIPASS.COM account. If you don't have a user account yet, create one and it will be linked to your MYDIGIPASS.COM account."),
    );

    $scenarios = array(
      'new_user' => t("I don't have a user account yet on this website. I want to create one and link it to my MYDIGIPASS.COM account."),
      'existing_user' => t("I already have a user account on this website. I want to link it to my MYDIGIPASS.COM account."),
    );

    $form['scenario'] = array(
      '#type' => 'radios',
      '#title' => t('Select one of the following options'),
      '#required' => TRUE,
      '#options' => $scenarios,
    );

    $form[] = array(
      '#type' => 'submit',
      '#value' => t('Continue'),
    );
  }

  return $form;
}

/**
 * Submit handler of the first page in the wizard to link a user.
 *
 * The submit handler only evaluates the end-user's choice:
 *  - If the end-user chose to create a new user, then he/she is redirected
 *    to mydigipass/link/new_user.
 *  - Otherwise the user already has an account and is therefore redirected
 *    to mydigipass/link/existing_user.
 */
function mydigipass_link_user_form_submit($form, &$form_state) {
  if ($form_state['values']['scenario'] == 'new_user') {
    drupal_goto('mydigipass/link/new_user');
  }
  else {
    drupal_goto('mydigipass/link/existing_user');
  }
}

/**
 * Page callback for 'mydigipass/link/new_user'.
 *
 * Second page in the wizard to link a Drupal user to MYDIGIPASS.COM.
 * This function checks whether it is allowed to create new user accounts on
 * the website. If not, then an error message is returned. If it is allowed,
 * then a form which resembles the user registration form is returned.
 * Using hook_form_alter an additional submit handler is added to the form
 * which causes that the newly created user is linked to the MYDIGIPASS.COM
 * account.
 *
 * @see mydigipass_forms()
 * @see mydigipass_form_alter()
 */
function mydigipass_link_new_user() {
  // Check if the integration is enabled. When integration is not enabled, a
  // user could arrive at the callback page when forcefully browsing to
  // the 'mydigipass/link/new_user' page.
  if (variable_get('mydigipass_integration_enabled', 0) == 0) {
    $output = t('The integration with MYDIGIPASS.COM has been disabled on this website.');
  }
  else {
    if (user_register_access()) {
      $output = t('Complete this form to create a new account on this website to link it to your MYDIGIPASS.COM account.');
      $output .= drupal_get_form('mydigipass_user_register');
    }
    else {
      $output = t("According to this website's policy it is not allowed to create new accounts.");
    }
  }

  return $output;
}

/**
 * Page callback for 'mydigipass/link/existing_user'.
 *
 * Second page in the wizard to link a Drupal user to MYDIGIPASS.COM.
 * This function returns a form which resembles the user login form.
 * Using hook_form_alter an additional submit handler is added to the form
 * which causes that the existing  user is linked to the MYDIGIPASS.COM
 * account.
 *
 * @see mydigipass_forms()
 * @see mydigipass_form_alter()
 */
function mydigipass_link_existing_user() {
  // Check if the integration is enabled. When integration is not enabled, a
  // user could arrive at the callback page when forcefully browsing to
  // the 'mydigipass/link/existing_user' page.
  if (variable_get('mydigipass_integration_enabled', 0) == 0) {
    $output = t('The integration with MYDIGIPASS.COM has been disabled on this website.');
  }
  else {
    $output = t('Complete this form if you already have an account on this website. Enter your credentials to link this account to MYDIGIPASS.COM. As soon as your account is linked, you will be able to log in to this site with your MYDIGIPASS.COM authenticator.');
    $output .= drupal_get_form('mydigipass_user_login');
  }

  return $output;
}

/**
 * Encodes an array into a Base64 string.
 *
 * This function encodes an array into a Base64 string so that it can be used
 * as a value to the state parameter. The state parameter is used in the OAuth
 * call to MYDIGIPASS.COM.
 *
 * @param array $state_array
 *   The array containing the values which have to be encoded.
 *
 * @return string
 *   The Base64 representation of the array.
 */
function _mydigipass_encode_state_array($state_array) {
  return base64_encode(json_encode($state_array));
}

/**
 * Decodes a Base64 string into an array.
 *
 * This function decodes a Base64 string into an array. The array contains the
 * values which were passed in the state parameter used in the OAuth call to
 * MYDIGIPASS.COM.
 *
 * @param string $state_string
 *   The Base64 string received by the callback function.
 *
 * @return array
 *   The decoded Base64 string.
 */
function _mydigipass_decode_state_array($state_string) {
  return json_decode(base64_decode($state_string, TRUE), TRUE);
}

/**
 * Implements hook_theme().
 */
function mydigipass_theme() {
  return array(
    'mydigipass_admin_settings_user_profile_fields_form' => array(
      'arguments' => array('form' => NULL),
    ),
  );
}

/**
 * Private helper function used for timing requests.
 *
 * Slightly modified port of the Drupal 7 timer_start() function.
 *
 * @return float
 *   Represents the current time in seconds since the Unix epoch accurate to
 *   the nearest microsecond.
 */
function _mydigipass_timer_start() {
  return microtime(TRUE);
}

/**
 * Reads the current timer value without stopping the timer.
 *
 * Slightly modified port of the Drupal 7 timer_read() function.
 *
 * @param float $start
 *   Represents the current time in seconds since the Unix epoch accurate to
 *   the nearest microsecond.
 *
 * @return float
 *   The current timer value in ms.
 */
function _mydigipass_timer_read($start) {
  $stop = microtime(TRUE);
  $diff = round(($stop - $start) * 1000, 2);
  return $diff;
}

/**
 * Private helper function which performs an HTTP request.
 *
 * This is a slightly modified version of the Drupal 7 implementation of
 * drupal_http_request(). The changes were made to make it work in Drupal 6.
 * This implementation is needed to be able to perform certificate validation.
 *
 * @param string $url
 *   A string containing a fully qualified URI.
 * @param array $options
 *   (optional) An array that can have one or more of the following elements:
 *   - headers: An array containing request headers to send as name/value pairs.
 *   - method: A string containing the request method. Defaults to 'GET'.
 *   - data: A string containing the request body, formatted as
 *     'param=value&param=value&...'. Defaults to NULL.
 *   - max_redirects: An integer representing how many times a redirect
 *     may be followed. Defaults to 3.
 *   - timeout: A float representing the maximum number of seconds the function
 *     call may take. The default is 30 seconds. If a timeout occurs, the error
 *     code is set to the HTTP_REQUEST_TIMEOUT constant.
 *   - context: A context resource created with stream_context_create().
 *
 * @return object
 *   An object that can have one or more of the following components:
 *   - request: A string containing the request body that was sent.
 *   - code: An integer containing the response status code, or the error code
 *     if an error occurred.
 *   - protocol: The response protocol (e.g. HTTP/1.1 or HTTP/1.0).
 *   - status_message: The status message from the response, if a response was
 *     received.
 *   - redirect_code: If redirected, an integer containing the initial response
 *     status code.
 *   - redirect_url: If redirected, a string containing the URL of the redirect
 *     target.
 *   - error: If an error occurred, the error message. Otherwise not set.
 *   - headers: An array containing the response headers as name/value pairs.
 *     HTTP header names are case-insensitive (RFC 2616, section 4.2), so for
 *     easy access the array keys are returned in lower case.
 *   - data: A string containing the response body that was received.
 */
function _mydigipass_http_request($url, array $options = array()) {
  $result = new stdClass();

  // Parse the URL and make sure we can handle the schema.
  $uri = @parse_url($url);

  if ($uri == FALSE) {
    $result->error = 'unable to parse URL';
    $result->code = -1001;
    return $result;
  }

  if (!isset($uri['scheme'])) {
    $result->error = 'missing schema';
    $result->code = -1002;
    return $result;
  }

  $timer = _mydigipass_timer_start();

  // Merge the default options.
  $options += array(
    'headers' => array(),
    'method' => 'GET',
    'data' => NULL,
    'max_redirects' => 3,
    'timeout' => 30.0,
    'context' => NULL,
  );

  // Merge the default headers.
  $options['headers'] += array(
    'User-Agent' => 'Drupal (+http://drupal.org/)',
  );

  // stream_socket_client() requires timeout to be a float.
  $options['timeout'] = (float) $options['timeout'];

  switch ($uri['scheme']) {
    case 'http':
    case 'feed':
      $port = isset($uri['port']) ? $uri['port'] : 80;
      $socket = 'tcp://' . $uri['host'] . ':' . $port;
      // RFC 2616: "non-standard ports MUST, default ports MAY be included".
      // We don't add the standard port to prevent from breaking rewrite rules
      // checking the host that do not take into account the port number.
      $options['headers']['Host'] = $uri['host'] . ($port != 80 ? ':' . $port : '');
      break;

    case 'https':
      // Note: Only works when PHP is compiled with OpenSSL support.
      $port = isset($uri['port']) ? $uri['port'] : 443;
      $socket = 'ssl://' . $uri['host'] . ':' . $port;
      $options['headers']['Host'] = $uri['host'] . ($port != 443 ? ':' . $port : '');
      break;

    default:
      $result->error = 'invalid schema ' . $uri['scheme'];
      $result->code = -1003;
      return $result;
  }

  if (empty($options['context'])) {
    $fp = @stream_socket_client($socket, $errno, $errstr, $options['timeout']);
  }
  else {
    // Create a stream with context. Allows verification of a SSL certificate.
    $fp = @stream_socket_client($socket, $errno, $errstr, $options['timeout'], STREAM_CLIENT_CONNECT, $options['context']);
  }

  // Make sure the socket opened properly.
  if (!$fp) {
    // When a network error occurs, we use a negative number so it does not
    // clash with the HTTP status codes.
    $result->code = -$errno;
    $result->error = trim($errstr) ? trim($errstr) : t('Error opening socket @socket', array('@socket' => $socket));

    return $result;
  }

  // Construct the path to act on.
  $path = isset($uri['path']) ? $uri['path'] : '/';
  if (isset($uri['query'])) {
    $path .= '?' . $uri['query'];
  }

  // Only add Content-Length if we actually have any content or if it is a POST
  // or PUT request. Some non-standard servers get confused by Content-Length in
  // at least HEAD/GET requests, and Squid always requires Content-Length in
  // POST/PUT requests.
  $content_length = strlen($options['data']);
  if ($content_length > 0 || $options['method'] == 'POST' || $options['method'] == 'PUT') {
    $options['headers']['Content-Length'] = $content_length;
  }

  // If the server URL has a user then attempt to use basic authentication.
  if (isset($uri['user'])) {
    $options['headers']['Authorization'] = 'Basic ' . base64_encode($uri['user'] . (isset($uri['pass']) ? ':' . $uri['pass'] : ''));
  }

  $request = $options['method'] . ' ' . $path . " HTTP/1.0\r\n";
  foreach ($options['headers'] as $name => $value) {
    $request .= $name . ': ' . trim($value) . "\r\n";
  }
  $request .= "\r\n" . $options['data'];
  $result->request = $request;
  // Calculate how much time is left of the original timeout value.
  $timeout = $options['timeout'] - _mydigipass_timer_read($timer) / 1000;
  if ($timeout > 0) {
    stream_set_timeout($fp, floor($timeout), floor(1000000 * fmod($timeout, 1)));
    fwrite($fp, $request);
  }

  // Fetch response. Due to PHP bugs like http://bugs.php.net/bug.php?id=43782
  // and http://bugs.php.net/bug.php?id=46049 we can't rely on feof(), but
  // instead must invoke stream_get_meta_data() each iteration.
  $info = stream_get_meta_data($fp);
  $alive = !$info['eof'] && !$info['timed_out'];
  $response = '';

  while ($alive) {
    // Calculate how much time is left of the original timeout value.
    $timeout = $options['timeout'] - _mydigipass_timer_read($timer) / 1000;
    if ($timeout <= 0) {
      $info['timed_out'] = TRUE;
      break;
    }
    stream_set_timeout($fp, floor($timeout), floor(1000000 * fmod($timeout, 1)));
    $chunk = fread($fp, 1024);
    $response .= $chunk;
    $info = stream_get_meta_data($fp);
    $alive = !$info['eof'] && !$info['timed_out'] && $chunk;
  }
  fclose($fp);

  if ($info['timed_out']) {
    $result->code = HTTP_REQUEST_TIMEOUT;
    $result->error = 'request timed out';
    return $result;
  }
  // Parse response headers from the response body.
  // Be tolerant of malformed HTTP responses that separate header and body with
  // \n\n or \r\r instead of \r\n\r\n.
  list($response, $result->data) = preg_split("/\r\n\r\n|\n\n|\r\r/", $response, 2);
  $response = preg_split("/\r\n|\n|\r/", $response);

  // Parse the response status line.
  list($protocol, $code, $status_message) = explode(' ', trim(array_shift($response)), 3);
  $result->protocol = $protocol;
  $result->status_message = $status_message;

  $result->headers = array();

  // Parse the response headers.
  while ($line = trim(array_shift($response))) {
    list($name, $value) = explode(':', $line, 2);
    $name = strtolower($name);
    if (isset($result->headers[$name]) && $name == 'set-cookie') {
      // RFC 2109: the Set-Cookie response header comprises the token Set-
      // Cookie:, followed by a comma-separated list of one or more cookies.
      $result->headers[$name] .= ',' . trim($value);
    }
    else {
      $result->headers[$name] = trim($value);
    }
  }

  $responses = array(
    100 => 'Continue',
    101 => 'Switching Protocols',
    200 => 'OK',
    201 => 'Created',
    202 => 'Accepted',
    203 => 'Non-Authoritative Information',
    204 => 'No Content',
    205 => 'Reset Content',
    206 => 'Partial Content',
    300 => 'Multiple Choices',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    304 => 'Not Modified',
    305 => 'Use Proxy',
    307 => 'Temporary Redirect',
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Time-out',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Large',
    415 => 'Unsupported Media Type',
    416 => 'Requested range not satisfiable',
    417 => 'Expectation Failed',
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Time-out',
    505 => 'HTTP Version not supported',
  );
  // RFC 2616 states that all unknown HTTP codes must be treated the same as the
  // base code in their class.
  if (!isset($responses[$code])) {
    $code = floor($code / 100) * 100;
  }
  $result->code = $code;

  switch ($code) {
    // 200 = OK.
    // 304 = Not modified.
    case 200:
    case 304:
      break;

    // 301: Moved permanently.
    // 302: Moved temporarily.
    // 307: Moved temporarily.
    case 301:
    case 302:
    case 307:
      $location = $result->headers['location'];
      $options['timeout'] -= _mydigipass_timer_read($timer) / 1000;
      if ($options['timeout'] <= 0) {
        $result->code = HTTP_REQUEST_TIMEOUT;
        $result->error = 'request timed out';
      }
      elseif ($options['max_redirects']) {
        // Redirect to the new location.
        $options['max_redirects']--;
        $result = _mydigipass_http_request($location, $options);
        $result->redirect_code = $code;
      }
      if (!isset($result->redirect_url)) {
        $result->redirect_url = $location;
      }
      break;

    default:
      $result->error = $status_message;
  }

  return $result;
}

/**
 * Generates an SSL context to be used for SSL certificate validation.
 *
 * Helper function which returns an array which can be used by
 * the stream_context_create function.
 *
 * @return array
 *   An array containing the necessary SSL context options to check the
 *   validity of the SSL server certificate.
 */
function _mydigipass_create_ssl_context() {
  if (variable_get('mydigipass_validate_certificate', 'disabled') == 'enabled') {
    $context = array(
      'ssl' => array(
        'verify_peer' => TRUE,
        'allow_self_signed' => FALSE,
        'CN_match' => 'www.mydigipass.com',
      ));
    $cafile = variable_get('mydigipass_validate_certificate_cafile', '');
    if (!empty($cafile)) {
      $context['ssl']['cafile'] = $cafile;
    }
  }
  else {
    $context = array();
  }

  return $context;
}

/**
 * Informs MYDIGIPASS.COM when linking a DRUPAL user with MYDIGIPASS.COM.
 *
 * After linking a MYDIGIPASS.COM user with a DRUPAL user, MYDIGIPASS.COM has
 * to be informed of this link. If this is not done, then the user risks of not
 * being able to login after several times.
 *
 * @return bool
 *   A boolean indicating whether contacting the MYDIGIPASS.COM API succeeded.
 */
function _mydigipass_api_uuid_connected($uuid) {
  $api_endpoint = _mydigipass_get_endpoint_url('api-uuids-connected');
  $options = array(
    'method' => 'POST',
    'headers' => array(
      'Accept' => 'application/json',
      'Content-Type' => 'application/json',
      'Authorization' => 'Basic ' . base64_encode(variable_get('mydigipass_client_id', '') . ':' . variable_get('mydigipass_client_secret', '')),
    ),
    'data' => json_encode(array("uuids" => array($uuid))),
  );

  $ssl_context_array = _mydigipass_create_ssl_context();
  if ($ssl_context_array === FALSE) {
    // A validation check failed.
    return FALSE;
  }
  $options['context'] = stream_context_create($ssl_context_array);
  $result = _mydigipass_http_request($api_endpoint, $options);

  // Fail secure: set return value to FALSE.
  $return = FALSE;

  switch ($result->code) {
    case 201:
      $return = TRUE;
      watchdog('mydigipass', 'Successfully informed MYDIGIPASS.COM of linked user with UUID %uuid.', array('%uuid' => $uuid));
      break;

    default:
      watchdog('mydigipass', 'An error occurred while contacting the MYDIGIPASS.COM connect API endpoint for UUID %uuid. The action will be retried during the next cron run.', array('%uuid' => $uuid), WATCHDOG_WARNING);
      variable_set('mydigipass_connect_api_inconsistency', TRUE);
  }

  return $return;
}

/**
 * Informs MYDIGIPASS.COM when unlinking a DRUPAL user with MYDIGIPASS.COM.
 *
 * After unlinking a MYDIGIPASS.COM user with a DRUPAL user, MYDIGIPASS.COM has
 * to be informed of this unlinking. This has an impact on the fees that have
 * to be paid to MYDIGIPASS.COM.
 *
 * @return bool
 *   A boolean indicating whether contacting the MYDIGIPASS.COM API succeeded.
 */
function _mydigipass_api_uuid_disconnected($uuid) {
  $api_endpoint = _mydigipass_get_endpoint_url('api-uuids-disconnected');
  $options = array(
    'method' => 'POST',
    'headers' => array(
      'Accept' => 'application/json',
      'Content-Type' => 'application/json',
      'Authorization' => 'Basic ' . base64_encode(variable_get('mydigipass_client_id', '') . ':' . variable_get('mydigipass_client_secret', '')),
    ),
    'data' => json_encode(array("uuids" => array($uuid))),
  );

  $ssl_context_array = _mydigipass_create_ssl_context();
  if ($ssl_context_array === FALSE) {
    // A validation check failed.
    return FALSE;
  }
  $options['context'] = stream_context_create($ssl_context_array);
  $result = _mydigipass_http_request($api_endpoint, $options);

  // Fail secure: set return value to FALSE.
  $return = FALSE;

  switch ($result->code) {
    case 201:
      $return = TRUE;
      watchdog('mydigipass', 'Successfully informed MYDIGIPASS.COM of unlinked user with UUID %uuid.', array('%uuid' => $uuid));
      break;

    default:
      watchdog('mydigipass', 'An error occurred while contacting the MYDIGIPASS.COM disconnect API endpoint for UUID %uuid. The action will be retried during the next cron run.', array('%uuid' => $uuid), WATCHDOG_WARNING);
      variable_set('mydigipass_connect_api_inconsistency', TRUE);
  }

  return $return;
}

/**
 * Sync the local database of connected users with the MYDIGIPASS.COM database.
 *
 * This function will compare the local database of connected users with the
 * list received from MYDIGIPASS.COM. If there are inconsistencies, then the
 * remote database will be updated.
 *
 * @return bool
 *   A boolean indicating whether the synchronisation succeeded or not.
 */
function _mydigipass_sync_connected_users() {
  // Get the list of connected users from MYDIGIPASS.COM.
  $api_endpoint = _mydigipass_get_endpoint_url('api-uuids-connected');
  $options = array(
    'method' => 'GET',
    'headers' => array(
      'Authorization' => 'Basic ' . base64_encode(variable_get('mydigipass_client_id', '') . ':' . variable_get('mydigipass_client_secret', '')),
      'Accept' => 'application/json',
    ),
  );

  $ssl_context_array = _mydigipass_create_ssl_context();
  if ($ssl_context_array === FALSE) {
    // A validation check failed.
    return FALSE;
  }
  $options['context'] = stream_context_create($ssl_context_array);
  $result = _mydigipass_http_request($api_endpoint, $options);

  switch ($result->code) {
    case 200:
      $response = json_decode($result->data);
      $mdp_uuids = (is_object($response) ? $response->uuids : array());
      break;

    default:
      watchdog('mydigipass', 'An error occurred while synchronizing the local database of connected users with the MYDIGIPASS.COM database. The action will be retried during the next cron run.', array(), WATCHDOG_WARNING);
      variable_set('mydigipass_connect_api_inconsistency', TRUE);
      return FALSE;
  }

  // Get the local list of connected users.
  $sql = 'SELECT mdp_uuid FROM {mydigipass_user_link}';
  $result = db_query($sql);
  $local_uuids = array();
  while ($row = db_fetch_object($result)) {
    $local_uuids[] = $row->mdp_uuid;
  }

  // Variable to contain the result of the sync action.
  $sync_result = TRUE;

  // Check which UUIDs exist locally and not at MYDIGIPASS.COM.
  // This can occur on 2 occasions:
  //  1) When users were already connected to MYDIGIPASS.COM, but the connected
  //     API is used for the first time (i.e. on update from 6.x-1.2 to 6.x-1.3.
  //  2) When a user removed the Drupal app from his launchpad.
  // In any case, we will tell MYDIGIPASS.COM that the uuid is still connected
  // locally.
  $diff = array_diff($local_uuids, $mdp_uuids);
  foreach ($diff as $uuid) {
    $sync_result &= _mydigipass_api_uuid_connected($uuid);
  }

  // Check which UUIDs exist at MYDIGIPASS.COM and not locally.
  // This can occur when access was revoked locally, but the sync with
  // MYDIGIPASS.COM has failed. We will tell MYDIGIPASS.COM that the uuid is
  // no longer connected locally.
  $diff = array_diff($mdp_uuids, $local_uuids);
  foreach ($diff as $uuid) {
    $sync_result &= _mydigipass_api_uuid_disconnected($uuid);
  }

  if ($sync_result) {
    watchdog('mydigipass', 'The local database of connected users was successfully synchronized with the MYDIGIPASS.COM database.');
  }
  else {
    watchdog('mydigipass', 'An error occurred while synchronizing the local database of connected users with the MYDIGIPASS.COM database. The action will be retried during the next cron run.', array(), WATCHDOG_WARNING);
  }

  return $sync_result;
}
